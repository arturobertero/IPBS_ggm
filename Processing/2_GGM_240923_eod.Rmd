---
title: "3_IPBS_mgm_230912"
author: "Arturo Bertero"
date: "2023-09-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(pacman)
p_load(tidyverse, here, sjlabelled, stringr, glue, EGAnet, janitor, haven,
       ggpubr, gridExtra, dplyr, GGally, qgraph, sjmisc, conflicted,
       sjPlot, sna, grid, psych, stargazer, mgm, ggplot2, boot,
       ggrepel, EGAnet, NetworkToolbox, Matrix, bootnet, matrixcalc, 
       openxlsx, devtools, jtools, corrr, patchwork, magick, hrbrthemes) 

options(scipen=999)

#conflicts
conflicts_prefer(dplyr::select)
conflicts_prefer(dplyr::filter)
conflicts_prefer(sna::degree)
conflicts_prefer(sna::closeness)
conflicts_prefer(sna::betweenness)

```

# Input

```{r}
#Load data
IPBS = readRDS((here("Input", "IPBS.rds")))

#Filter smaller dataset
att = IPBS %>% 
  dplyr::select(c(L_R:ukrai)) 

#Partitions
load(file = here("Input", "Partitions", "pol_int_partitions.RData"))
load(file = here("Input", "Partitions", "pol_int_partitions_2_1.RData"))
load(file = here("Input", "Partitions", "pol_int_partitions_2_2.RData"))
load(file = here("Input", "Partitions", "educ_partitions.RData"))
load(file = here("Input", "Partitions", "vote_partitions.RData"))

#Fast running (run [0] or skip [1] bootnet and NCT)
fast_running = 1
```

# Processing

##  Cor network estimation 

```{r}
# Define shortnames, longnames, and groupings as per your original code
shortnames <- names(att)
longnames <- c("Left right","Propensity to vote for PD",
               "Propensity to vote for FI","Propensity to vote for L",
               "Propensity to vote for M5S","Propensity to vote for FDI",
               "Step child adoption","Abortion","Euthanasia","Omosexual marriage",
               "Redistribution","Flat tax","Minimum wage","Citizenship income",
               "Globalization","Immigration","Big government",
               "Public vs private","Weapons to Ukraine")

Totalgroup_comm <- list(
  "Symbolic" = c(1:6),
  "Operational" = c(7:19)
)

Totalgroup_cols <- c("#966FD6B3","#008B8BB3")  
```

```{r}
# estimation on att

#remove labels
att = sapply(att, haven::zap_labels)

#declare operational or symbolic
nature = c(rep("Symbolic", 6),
            rep("Operational", 13))

#Fit cor network 
att_net = cor_auto(att, npn.SKEPTIC = T, #Nonparanormal transformation (HUGE)
                        ordinalLevelMax = 7, #from keskinturk
                        forcePD = TRUE,
                        missing = "pairwise",
                        verbose = FALSE)

#square the matrix
att_net = att_net^2

#plot
qgraph(att_net,
         fade = TRUE, layout = "spring", theme = "colorblind",  
         labels = shortnames, nodeNames = longnames,
         vsize = 7.0, label.cex = 1.1, esize = 15, vTrans = 255,
         groups = Totalgroup_comm, color = Totalgroup_cols,
         legend = F, legend.cex = 0.40, title = "Correlational network",
         filetype = "jpg", filename = here("Output", "Supplement", "att"))
```

```{r}
# Function to ensure input data is in matrix/data frame format
prepare_data <- function(data) {
  if (is.list(data)) {
    return(as.data.frame(do.call(cbind, data)))  # Convert list to data frame
  } else if (is.vector(data)) {
    return(as.data.frame(matrix(data, nrow = length(data))))  # Convert vector to a data frame
  } else {
    return(as.data.frame(data))  # Already in correct format
  }
}

# Function to fit and plot correlation networks and save the plots to a file
generate_network_plots <- function(low_data, high_data, shortnames, longnames, group_names, group_colors, title_low, title_high, file_base) {
  # Remove labels
  low_data <- sapply(low_data, haven::zap_labels)
  high_data <- sapply(high_data, haven::zap_labels)
  
  # Fit GGM for low data
  low_data_net <- cor_auto(low_data, npn.SKEPTIC = TRUE, ordinalLevelMax = 7, forcePD = TRUE, missing = "pairwise", verbose = FALSE)
  low_data_net <- low_data_net^2  # Square the matrix
  
  # Fit GGM for high data
  high_data_net <- cor_auto(high_data, npn.SKEPTIC = TRUE, ordinalLevelMax = 7, forcePD = TRUE, missing = "pairwise", verbose = FALSE)
  high_data_net <- high_data_net^2  # Square the matrix
  
  # Save plot for low data
  set.seed(1)
  qgraph(low_data_net,
         fade = TRUE, layout = "spring", theme = "colorblind",  
         labels = shortnames, nodeNames = longnames,
         vsize = 7.0, label.cex = 1.1, esize = 15, vTrans = 255,
         groups = group_names, color = group_colors,
         legend = F, legend.cex = 0.40, title = title_low,
         filetype = "jpg", filename = here("Output", "Supplement", paste0(file_base, "_Low")))
  
  # Save plot for high data
  set.seed(1)
  qgraph(high_data_net,
         fade = TRUE, layout = "spring", theme = "colorblind",  
         labels = shortnames, nodeNames = longnames,
         vsize = 7.0, label.cex = 1.1, esize = 15, vTrans = 255,
         groups = group_names, color = group_colors,
         legend = F, legend.cex = 0.40, title = title_high,
         filetype = "jpg", filename = here("Output", "Supplement", paste0(file_base, "_High")))
}

# Generate Political Interest plots and save them
generate_network_plots(
  low_data = prepare_data(polint_2_1_l),
  high_data = prepare_data(polint_2_1_h),
  shortnames = shortnames, 
  longnames = longnames,
  group_names = Totalgroup_comm, 
  group_colors = Totalgroup_cols, 
  title_low = "Political Interest - Low",
  title_high = "Political Interest - High",
  file_base = "Fig_Political_Interest"
)

# Generate Education plots and save them
generate_network_plots(
  low_data = prepare_data(educ_low),
  high_data = prepare_data(educ_high),
  shortnames = shortnames, 
  longnames = longnames,
  group_names = Totalgroup_comm, 
  group_colors = Totalgroup_cols, 
  title_low = "Education - Low",
  title_high = "Education - High",
  file_base = "Fig_Education"
)

```


## MGMs

```{r}
# mgm on att
  mgm_att <- mgm(att, type = rep("g", length(shortnames)), 
                   level = rep(1, length(shortnames)), lambdaSel = "EBIC", ruleReg = "OR")
  
  # Predictability
  pred_att <- predict(object = mgm_att, data = att, errorCon = 'R2')
  
  # Plot the MGM network
  graph_mgm <- qgraph(mgm_att$pairwise$wadj, layout = 'spring',
                      labels = shortnames, nodeNames = longnames,  
                      groups = Totalgroup_comm, color = Totalgroup_cols, 
                      legend = T, legend.cex = 0.33, title = "mgm",
                      edge.color = mgm_att$pairwise$edgecolor_cb, vTrans = 255,
                      borders = T, vsize = 7.0, esize = 15, GLratio = 2,
                      pie = pred_att$errors[,2], pieColor = rep('#FFFF00', length(shortnames)),
                      filetype = "jpg",  
                      filename = here("Output", "Supplement", "att_mgm"))

```


```{r}
# Function to ensure input data is in matrix format
prepare_matrix_data <- function(data) {
  if (!is.matrix(data)) {
    return(as.matrix(data))  # Convert to matrix if it's not already
  }
  return(data)
}

# Function to fit MGM and plot the results
fit_and_plot_mgm <- function(data, shortnames, longnames, mgm_groups, mgm_colors, file_base) {
  # Prepare data as a matrix
  data_matrix <- prepare_matrix_data(data)
  
  # Fit MGM model (all continuous variables)
  mgm_model <- mgm(data_matrix, type = rep("g", length(shortnames)), 
                   level = rep(1, length(shortnames)), lambdaSel = "EBIC", ruleReg = "OR")
  
  # Predictability
  pred_mgm <- predict(object = mgm_model, data = data_matrix, errorCon = 'R2')
  
  # Plot the MGM network
  graph_mgm <- qgraph(mgm_model$pairwise$wadj, layout = 'spring',
                      labels = shortnames, nodeNames = longnames,  
                      groups = mgm_groups, color = mgm_colors, 
                      legend = F, legend.cex = 0.33, vTrans = 255,
                      edge.color = mgm_model$pairwise$edgecolor_cb,
                      borders = T, vsize = 7.0, esize = 15, GLratio = 2,
                      pie = pred_mgm$errors[,2], pieColor = rep('#FFFF00', length(shortnames)),
                      filetype = "jpg",  
                      filename = here("Output", "Supplement", file_base))
}

# Fit and plot MGM for all datasets
datasets <- list(
  "pol_int_low" = polint_2_1_l,
  "pol_int_high" = polint_2_1_h,
  "educ_low" = educ_low,
  "educ_high" = educ_high
)

# Loop through datasets and apply MGM fitting and plotting
for (name in names(datasets)) {
  fit_and_plot_mgm(
    data = datasets[[name]],
    shortnames = shortnames, 
    longnames = longnames,
    mgm_groups = Totalgroup_comm, 
    mgm_colors = Totalgroup_cols, 
    file_base = paste0(name, "_mgm")
  )
}


```


## Bootstrap analyses (cor)

```{r}
if (fast_running==0) {

##############################
#Bootstrapped on full samples
##############################

#boots_att
boot_att = zap_labels(att) %>%
          data.frame()

df.boot_att = bootnet(boot_att, nBoots = 10000, nCores = 8,
                     default = "cor", type = "nonparametric",
                     corMethod = "cor_auto", corArgs = list(
                        npn.SKEPTIC = T,
                        ordinalLevelMax = 7, 
                        forcePD = TRUE,
                        missing = "pairwise",
                        verbose = FALSE),
                        computeCentrality = FALSE)
#Save Bootnets
save(df.boot_att, file = here("Input", "Boots", "boots_att.RData"))

###############
#Bootstrap pint
###############

#low
polint_low_and_midlow = zap_labels(polint_low_and_midlow) %>%
          data.frame()
df.boot_pint_l <- bootnet(polint_low_and_midlow, nBoots = 10000, nCores = 8,
                     default = "cor", type = "nonparametric",
                     corMethod = "cor_auto", corArgs = list(
                        npn.SKEPTIC = T,
                        ordinalLevelMax = 7, 
                        forcePD = TRUE,
                        missing = "pairwise",
                        verbose = FALSE),
                        computeCentrality = FALSE)

#mid
pol_int_midhigh = zap_labels(pol_int_midhigh) %>%
          data.frame()
df.boot_pint_m <- bootnet(pol_int_midhigh, nBoots = 10000, nCores = 8,
                     default = "cor", type = "nonparametric",
                     corMethod = "cor_auto", corArgs = list(
                        npn.SKEPTIC = T,
                        ordinalLevelMax = 7, 
                        forcePD = TRUE,
                        missing = "pairwise",
                        verbose = FALSE),
                        computeCentrality = FALSE)

#high
pol_int_high = zap_labels(pol_int_high) %>%
          data.frame()
df.boot_pint_h <- bootnet(pol_int_high, nBoots = 10000, nCores = 8,
                     default = "cor", type = "nonparametric",
                     corMethod = "cor_auto", corArgs = list(
                        npn.SKEPTIC = T,
                        ordinalLevelMax = 7, 
                        forcePD = TRUE,
                        missing = "pairwise",
                        verbose = FALSE),
                        computeCentrality = FALSE)

#Save Bootnets
save(df.boot_pint_l,df.boot_pint_m,df.boot_pint_h,
     file = here("Input", "Boots", "boots_pint.RData"))

###############
#Bootstrap educ
###############

#low
educ_low = zap_labels(educ_low) %>%
          data.frame()
df.boot_educ_l <- bootnet(educ_low, nBoots = 10000, nCores = 8,
                     default = "cor", type = "nonparametric",
                     corMethod = "cor_auto", corArgs = list(
                        npn.SKEPTIC = T,
                        ordinalLevelMax = 7, 
                        forcePD = TRUE,
                        missing = "pairwise",
                        verbose = FALSE),
                        computeCentrality = FALSE)

#high
educ_high = zap_labels(educ_high) %>%
          data.frame()
df.boot_educ_h <- bootnet(educ_high, nBoots = 10000, nCores = 8,
                     default = "cor", type = "nonparametric",
                     corMethod = "cor_auto", corArgs = list(
                        npn.SKEPTIC = T,
                        ordinalLevelMax = 7, 
                        forcePD = TRUE,
                        missing = "pairwise",
                        verbose = FALSE),
                        computeCentrality = FALSE)

#Save Bootnets
save(df.boot_educ_l,df.boot_educ_h,
     file = here("Input", "Boots", "boots_educ.RData"))

#################
#Additional pint#
#################

# On 2_1

#low
polint_l_2_1 = zap_labels(polint_2_1_l) %>%
          data.frame()
df.boot_pint_l_2_1 <- bootnet(polint_l_2_1, nBoots = 10000, nCores = 8,
                     default = "cor", type = "nonparametric",
                     corMethod = "cor_auto", corArgs = list(
                        npn.SKEPTIC = T,
                        ordinalLevelMax = 7, 
                        forcePD = TRUE,
                        missing = "pairwise",
                        verbose = FALSE),
                        computeCentrality = FALSE)

#high
polint_h_2_1 = zap_labels(polint_2_1_h) %>%
          data.frame()
df.boot_pint_h_2_1 <- bootnet(polint_h_2_1, nBoots = 10000, nCores = 8,
                     default = "cor", type = "nonparametric",
                     corMethod = "cor_auto", corArgs = list(
                        npn.SKEPTIC = T,
                        ordinalLevelMax = 7, 
                        forcePD = TRUE,
                        missing = "pairwise",
                        verbose = FALSE),
                        computeCentrality = FALSE)

#Save Bootnets
save(df.boot_pint_l_2_1,df.boot_pint_h_2_1,
     file = here("Input", "Boots", "boots_pint_2_1.RData"))

# On 2_2

#low
polint_l_2_2 = zap_labels(polint_2_2_l) %>%
          data.frame()
df.boot_pint_l_2_2 <- bootnet(polint_l_2_2, nBoots = 10000, nCores = 8,
                     default = "cor", type = "nonparametric",
                     corMethod = "cor_auto", corArgs = list(
                        npn.SKEPTIC = T,
                        ordinalLevelMax = 7, 
                        forcePD = TRUE,
                        missing = "pairwise",
                        verbose = FALSE),
                        computeCentrality = FALSE)

#high
polint_h_2_2 = zap_labels(polint_2_2_h) %>%
          data.frame()
df.boot_pint_h_2_2 <- bootnet(polint_h_2_2, nBoots = 10000, nCores = 8,
                     default = "cor", type = "nonparametric",
                     corMethod = "cor_auto", corArgs = list(
                        npn.SKEPTIC = T,
                        ordinalLevelMax = 7, 
                        forcePD = TRUE,
                        missing = "pairwise",
                        verbose = FALSE),
                        computeCentrality = FALSE)

#Save Bootnets
save(df.boot_pint_l_2_2,df.boot_pint_h_2_2,
     file = here("Input", "Boots", "boots_pint_2_2.RData"))

} else {
  
  #Boots
load(file = here("Input", "Boots", "boots_att.RData"))
load(file = here("Input", "Boots", "boots_pint.RData"))
load(file = here("Input", "Boots", "boots_educ.RData"))
load(file = here("Input", "Boots", "boots_pint_2_1.RData"))
load(file = here("Input", "Boots", "boots_pint_2_2.RData"))
}
```

## Bootstrap analyses (pcor)

```{r}
if (fast_running==0) {

##############################
#Bootstrapped on full samples
##############################

#boots_att_pc
df.boot_att_pc <- bootnet(boot_att, nBoots = 10000, nCores = 8,
                     default = "EBICglasso", statistics = c("edge"),
                        computeCentrality = FALSE)
#Save Bootnets
save(df.boot_att_pc, file = here("Input", "Boots", "boots_att_pc.RData"))


###############
#Bootstrap pint
###############

#boots_pint_l_pc
df.boot_pint_l_pc <- bootnet(polint_low_and_midlow, nBoots = 10000, nCores = 8,
                     default = "EBICglasso", statistics = c("edge"),
                        computeCentrality = FALSE)

#boots_pint_m_pc
df.boot_pint_m_pc <- bootnet(pol_int_midhigh, nBoots = 10000, nCores = 8,
                     default = "EBICglasso", statistics = c("edge"),
                        computeCentrality = FALSE)

#boots_pint_h_pc
df.boot_pint_h_pc <- bootnet(pol_int_high, nBoots = 10000, nCores = 8,
                     default = "EBICglasso", statistics = c("edge"),
                        computeCentrality = FALSE)
#Save Bootnets 
save(df.boot_pint_l_pc,df.boot_pint_m_pc,df.boot_pint_h_pc,
     file = here("Input", "Boots", "boots_pint_pc.RData"))


###############
#Bootstrap educ
###############

#boots_educ_l_pc
df.boot_educ_l_pc <- bootnet(educ_low, nBoots = 10000, nCores = 8,
                     default = "EBICglasso", statistics = c("edge"),
                        computeCentrality = FALSE)

#boots_educ_h_pc
df.boot_educ_h_pc <- bootnet(educ_high, nBoots = 10000, nCores = 8,
                     default = "EBICglasso", statistics = c("edge"),
                        computeCentrality = FALSE)

#Save Bootnets
save(df.boot_educ_l_pc,df.boot_educ_h_pc,
     file = here("Input", "Boots", "boots_educ_pc.RData"))



#################
#Additional pint#
#################

# On 2_1

#low
df.boot_pint_l_2_1_pc <- bootnet(polint_l_2_1, nBoots = 10000, nCores = 8,
                     default = "EBICglasso", statistics = c("edge"),
                        computeCentrality = FALSE)

#high
df.boot_pint_h_2_1_pc <- bootnet(polint_h_2_1, nBoots = 10000, nCores = 8,
                     default = "EBICglasso", statistics = c("edge"),
                        computeCentrality = FALSE)

#Save Bootnets
save(df.boot_pint_l_2_1_pc,df.boot_pint_h_2_1_pc,
     file = here("Input", "Boots", "boots_pint_2_1_pc.RData"))

# On 2_2

#low
df.boot_pint_l_2_2_pc <- bootnet(polint_l_2_2, nBoots = 10000, nCores = 8,
                     default = "EBICglasso", statistics = c("edge"),
                        computeCentrality = FALSE)

#high
df.boot_pint_h_2_2_pc <- bootnet(polint_h_2_2, nBoots = 10000, nCores = 8,
                     default = "EBICglasso", statistics = c("edge"),
                        computeCentrality = FALSE)

#Save Bootnets
save(df.boot_pint_l_2_2_pc,df.boot_pint_h_2_2_pc,
     file = here("Input", "Boots", "boots_pint_2_2_pc.RData"))

} else {
  
  #Boots
load(file = here("Input", "Boots", "boots_att_pc.RData"))
load(file = here("Input", "Boots", "boots_pint_pc.RData"))
load(file = here("Input", "Boots", "boots_educ_pc.RData"))
load(file = here("Input", "Boots", "boots_pint_2_1_pc.RData"))
load(file = here("Input", "Boots", "boots_pint_2_2_pc.RData"))
}
```

## Extract info from boots

```{r}
# Function to process each dataset
process_boots_data <- function(df_boot) {
  # Extract the matrices
  matrix_list <- lapply(1:10000, function(i) {
    df_boot[["boots"]][[i]][["graph"]]
  })
  
  # Calculate the mean of the squared matrix for each matrix
  mean_values <- sapply(matrix_list, function(mat) {
    squared_matrix <- mat^2
    mean(squared_matrix)
  })
  
  return(mean_values)
}

#######
##cor##
#######

# Apply the function to pint dataset
cons_pint_l <- process_boots_data(df.boot_pint_l)
cons_pint_m <- process_boots_data(df.boot_pint_m)
cons_pint_h <- process_boots_data(df.boot_pint_h)

# Apply the function to pint 2_1 dataset
cons_pint_l_2_1 <- process_boots_data(df.boot_pint_l_2_1)
cons_pint_h_2_1 <- process_boots_data(df.boot_pint_h_2_1)

# Apply the function to pint 2_2 dataset
cons_pint_l_2_2 <- process_boots_data(df.boot_pint_l_2_2)
cons_pint_h_2_2 <- process_boots_data(df.boot_pint_h_2_2)

# Apply the function to educ dataset
cons_educ_l <- process_boots_data(df.boot_educ_l)
cons_educ_h <- process_boots_data(df.boot_educ_h)

########
##pcor##
########

# Apply the function to pint dataset
cons_pint_l_pc <- process_boots_data(df.boot_pint_l_pc)
cons_pint_m_pc <- process_boots_data(df.boot_pint_m_pc)
cons_pint_h_pc <- process_boots_data(df.boot_pint_h_pc)

# Apply the function to pint 2_1 dataset
cons_pint_l_2_1_pc <- process_boots_data(df.boot_pint_l_2_1_pc)
cons_pint_h_2_1_pc <- process_boots_data(df.boot_pint_h_2_1_pc)  

# Apply the function to pint 2_2 dataset
cons_pint_l_2_2_pc <- process_boots_data(df.boot_pint_l_2_2_pc)
cons_pint_h_2_2_pc <- process_boots_data(df.boot_pint_h_2_2_pc)  

# Apply the function to educ dataset
cons_educ_l_pc <- process_boots_data(df.boot_educ_l_pc)
cons_educ_h_pc <- process_boots_data(df.boot_educ_h_pc)
```


## H1 and H2 

### Multiplot networks att

```{r}
# Figure_1 (cor vs mgm)
img1 <- image_read(here("Output", "Supplement", "att.jpg"))
img2 <- image_read(here("Output", "Supplement", "att_mgm.jpg"))
combined_img <- image_append(c(img1, img2), stack = FALSE)
image_write(combined_img, path = here("Output", "Article", "Figure_1.jpg"))

```


### Violins

```{r}
# Function to create and print plots with custom colors for Correlational network and mgm
create_plot <- function(df_l, df_m = NULL, df_h, df_l_pc, df_m_pc = NULL, df_h_pc, x_axis_label) {
  # Create vectors for pint (if applicable) or education
  if (!is.null(df_m)) {
    pint <- c(rep("Low", 10000), rep("Medium", 10000), rep("High", 10000))
    pint <- factor(pint, levels = c("Low", "Medium", "High"))
    
    # Combine the cons_pint and cons_pint_pc data into one data frame
    const_val <- c(df_l, df_m, df_h, df_l_pc, df_m_pc, df_h_pc)
    data_type <- rep(c("Correlational network", "mgm"), each = 30000)
    pint_vector <- rep(pint, 2)  # Repeat pint vector twice for Correlational network and mgm

  } else {
    pint <- c(rep("Low", 10000), rep("High", 10000))
    pint <- factor(pint, levels = c("Low", "High"))
    
    # Combine the cons_pint and cons_pint_pc data into one data frame (only low and high)
    const_val <- c(df_l, df_h, df_l_pc, df_h_pc)
    data_type <- rep(c("Correlational network", "mgm"), each = 20000)
    pint_vector <- rep(pint, 2)  # Repeat pint vector twice for Correlational network and mgm
  }

  mcon_data <- data.frame(
    const_val = const_val,
    pint = pint_vector,
    data_type = data_type
  )

  # Calculate quantile-based confidence intervals (90% CI)
  mcon_data_summary <- mcon_data %>%
    group_by(pint, data_type) %>%
    summarise(
      m = mean(const_val),
      ymin = quantile(const_val, 0.025),  # 2.5 percentile
      ymax = quantile(const_val, 0.975)   # 97.5 percentile
    )

# Create the faceted plot with different y-axis scales and custom colors
plot <- ggplot() +
  geom_violin(data = mcon_data, aes(x = pint, y = const_val, fill = data_type), 
              scale = "count", width = 0.6) +  # Map fill to data_type
  geom_errorbar(data = mcon_data_summary, aes(x = pint, ymin = ymin, ymax = ymax), 
                width = 0.2, linewidth = 0.7, color = "black") +
  theme_ipsum() +
  ylab("Average Tightness") +
  xlab(x_axis_label) +  # Set the dynamic x-axis label here
  facet_wrap(~data_type, scales = "free_y") +  # Allow different y-axis scales
  scale_fill_manual(values = c("Correlational network" = "#966FD6B3", "mgm" = "#008B8BB3")) +  # Custom colors
  theme(
    axis.title.x = element_text(), 
    legend.position = "none",
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)  # Increase font size, center the title
  )

# Print the plot
print(plot)
}

# Create and print the H1_pint plot (with three levels)
H1 = create_plot(cons_pint_l, cons_pint_m, cons_pint_h, cons_pint_l_pc, cons_pint_m_pc, cons_pint_h_pc, "Political Interest") +
  ggtitle("Political Interest") + 
  theme(plot.title = element_text(size = 20, face = "bold", hjust = 0.5))

# Create and print the H1_pint_2_1 plot (with two levels)
H1_2_1 = create_plot(cons_pint_l_2_1, NULL, cons_pint_h_2_1, cons_pint_l_2_1_pc, NULL, cons_pint_h_2_1_pc, "Political Interest - Option 1") +
  ggtitle("Political Interest - Option 1") + 
  theme(plot.title = element_text(size = 20, face = "bold", hjust = 0.5))

# Create and print the H1_pint_2_2 plot (with two levels)
H1_2_2 = create_plot(cons_pint_l_2_2, NULL, cons_pint_h_2_2, cons_pint_l_2_2_pc, NULL, cons_pint_h_2_2_pc, "Political Interest - Option 2") +
  ggtitle("Political Interest - Option 2") + 
  theme(plot.title = element_text(size = 20, face = "bold", hjust = 0.5))

# Create and print the H2_educ plot (with two levels and x-axis label "Education")
H2 = create_plot(cons_educ_l, NULL, cons_educ_h, cons_educ_l_pc, NULL, cons_educ_h_pc, "Education") +
  ggtitle("Education") + 
  theme(plot.title = element_text(size = 20, face = "bold", hjust = 0.5))

```

```{r}
# Figure_2 multiplot
Figure_2 = H1 / H2

ggsave(here("Output", "Article", "Figure_2.jpg"), Figure_2, width = 12, height = 8, dpi = 300)

# Fig_3 multiplot
Fig_3 = H1_2_1 / H1_2_2

ggsave(here("Output", "Supplement", "Fig_3.jpg"), Fig_3, width = 12, height = 8, dpi = 300)
```

### R2 lollipop

```{r}
# Initialize an empty list to store predictions
pred_list <- list()

# Loop through datasets and store R2 values
for (name in names(datasets)) {
  # Fit MGM and get R2 predictions
  data_matrix <- prepare_matrix_data(datasets[[name]])
  mgm_model <- mgm(data_matrix, type = rep("g", length(shortnames)), 
                   level = rep(1, length(shortnames)), lambdaSel = "EBIC", ruleReg = "OR")
  pred_mgm <- predict(object = mgm_model, data = data_matrix, errorCon = 'R2')
  
  # Store the R2 values with the variable names
  pred_list[[name]] <- tibble(Variable = pred_mgm$errors[, 1], 
                              R2 = pred_mgm$errors[, 2], 
                              group = name)
}

# Combine all predictions into a single data frame
pred_df <- bind_rows(pred_list) %>%
  pivot_wider(names_from = group, values_from = R2)

# Save prediction table to Word file
sjPlot::tab_df(pred_df, file = here("Output", "Supplement", "Tab_2.doc"))

# Summarize the difference in R2 values between groups
sum_pred_df <- tibble(
  sum_educ = sum(pred_df$educ_high) - sum(pred_df$educ_low),
  sum_pint = sum(pred_df$pol_int_high) - sum(pred_df$pol_int_low)
)

# Reshape the data without including 'att' group
plot_data <- pred_df %>%
  pivot_longer(cols = -Variable, names_to = "group", values_to = "value") %>%
  filter(!str_detect(group, "att")) %>%
  mutate(
    type = case_when(
      str_detect(group, "educ") ~ "educ",
      str_detect(group, "pol_int") ~ "pint",
      TRUE ~ NA_character_
    ),
    group = case_when(
      str_detect(group, "_low") ~ "low",
      str_detect(group, "_high") ~ "high",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(group))  # Remove rows with NA in group

create_facet_plot <- function(data) {
  # Prepare data for plotting
  data_wide <- data %>%
    pivot_wider(names_from = group, values_from = value) %>%
    arrange(desc(high)) %>%
    mutate(Variable = factor(Variable, levels = unique(Variable)))

  # Create the plot with facet wrap
  ggplot(data_wide) +
    geom_segment(aes(x = Variable, xend = Variable, y = low, yend = high), color = "grey") +
    geom_point(aes(x = Variable, y = low, color = "Low Group"), size = 3) +
    geom_point(aes(x = Variable, y = high, color = "High Group"), size = 3) +
    coord_flip() +
    scale_color_manual(values = c("Low Group" = "#966FD6B3", "High Group" = "#008B8BB3")) + 
    theme_ipsum() +
    theme(
      legend.position = "bottom",  # Move legend to bottom
      axis.title.y = element_text(size = 14, face = "bold"),
      plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),  # Match title size with aspl_violin_plot
      legend.title = element_text(size = 12, face = "bold")
    ) +
    facet_wrap(~ type, scales = "fixed",  # Ensure same x-axis scale for all panels
               labeller = as_labeller(c("educ" = "Education", "pint" = "Political Interest"))) +  # Change panel labels
    xlab("") +
    ylab("R²") +  # x-axis label present for both panels
    ggtitle("Comparison of node-wise R²")  # General title for the plot
}

# Create the plot
facet_r2_plot <- create_facet_plot(plot_data)

```

### ASPL

```{r}
# Function to calculate ASPL, exclude outliers, and return bootstrapped 90% asymmetrical CIs
aspl_from_boots_with_ci <- function(df_boot) {
  
  # Extract the matrices
  matrix_list <- lapply(1:10000, function(i) {
    df_boot[["boots"]][[i]][["graph"]]
  })
  
  # Ensure that all values in the matrices are non-negative by taking the absolute value
  matrix_list <- lapply(matrix_list, function(mat) {
    mat <- abs(mat)  # Take the absolute value of all matrix elements
    return(mat)
  })
  
  # Calculate ASPL for each matrix using pathlengths function from NetworkToolbox
  aspl_values <- sapply(matrix_list, function(mat) {
    aspl <- tryCatch({
      pathlengths(mat, weighted = TRUE)$ASPL  # Calculate ASPL for the matrix
    }, error = function(e) {
      return(NA)  # If calculation fails, return NA
    })
    return(aspl)
  })
  
  # Remove any NA values (in case of calculation errors)
  aspl_values <- aspl_values[!is.na(aspl_values)]
  
  # Calculate mean and standard deviation of ASPL values for this group
  mean_aspl <- mean(aspl_values, na.rm = TRUE)
  sd_aspl <- sd(aspl_values, na.rm = TRUE)
  
  # Exclude outliers: keep only values within ±3 standard deviations from the mean for this group
  aspl_values_filtered <- aspl_values #[aspl_values >= (mean_aspl - 3 * sd_aspl) & 
                                      # aspl_values <= (mean_aspl + 3 * sd_aspl)]
  
  # Calculate asymmetrical 90% bootstrapped confidence intervals using quantiles
  ci_lower <- quantile(aspl_values_filtered, 0.025, na.rm = TRUE)  # 2.5th percentile
  ci_upper <- quantile(aspl_values_filtered, 0.925, na.rm = TRUE)  # 92.5th percentile
  
  # Return the ASPL values with outliers removed along with CIs and mean
  return(list(mean_aspl = mean(aspl_values_filtered, na.rm = TRUE),
              ci_lower = ci_lower, 
              ci_upper = ci_upper,
              aspl_values = aspl_values_filtered))  # Also return the filtered values for box plot
}

# Apply the updated function to datasets for political interest and education
#aspl_pint_l_2_1_pc <- aspl_from_boots_with_ci(df.boot_pint_l_2_1_pc)
#aspl_pint_h_2_1_pc <- aspl_from_boots_with_ci(df.boot_pint_h_2_1_pc)
#
#aspl_educ_l_pc <- aspl_from_boots_with_ci(df.boot_educ_l_pc)
#aspl_educ_h_pc <- aspl_from_boots_with_ci(df.boot_educ_h_pc)

#Load
load(file = here("Input", "ASPL", "aspl_educ_h.RData"))
load(file = here("Input", "ASPL", "aspl_educ_l.RData"))
load(file = here("Input", "ASPL", "aspl_pint_h.RData"))
load(file = here("Input", "ASPL", "aspl_pint_l.RData"))

# Save
save(aspl_pint_l_2_1_pc, file = here("Input", "ASPL", "aspl_pint_l.RData"))
save(aspl_pint_h_2_1_pc, file = here("Input", "ASPL", "aspl_pint_h.RData"))

save(aspl_educ_l_pc, file = here("Input", "ASPL", "aspl_educ_l.RData"))
save(aspl_educ_h_pc, file = here("Input", "ASPL", "aspl_educ_h.RData"))

# Prepare the data for box plot (using all ASPL values, including outliers)
plot_data <- data.frame(
  type = c(rep("pint", length(aspl_pint_l_2_1_pc$aspl_values)), rep("pint", length(aspl_pint_h_2_1_pc$aspl_values)),
           rep("educ", length(aspl_educ_l_pc$aspl_values)), rep("educ", length(aspl_educ_h_pc$aspl_values))),
  group = c(rep("low", length(aspl_pint_l_2_1_pc$aspl_values)), rep("high", length(aspl_pint_h_2_1_pc$aspl_values)),
            rep("low", length(aspl_educ_l_pc$aspl_values)), rep("high", length(aspl_educ_h_pc$aspl_values))),
  aspl_values = c(aspl_pint_l_2_1_pc$aspl_values, aspl_pint_h_2_1_pc$aspl_values, 
                  aspl_educ_l_pc$aspl_values, aspl_educ_h_pc$aspl_values)
)

# Rename 'type' categories for better labels
plot_data <- plot_data %>%
  mutate(
    type = case_when(
      type == "educ" ~ "Education",
      type == "pint" ~ "Political Interest"
    )
  )

# Calculate mean and standard deviation of ASPL values for each group and type
plot_data_summary <- plot_data %>%
  group_by(type, group) %>%
  summarise(mean_aspl = mean(aspl_values, na.rm = TRUE),
            sd_aspl = sd(aspl_values, na.rm = TRUE), .groups = "drop")  # Include summary stats

# Merge summary statistics back into plot_data for each observation
plot_data <- plot_data %>%
  left_join(plot_data_summary, by = c("type", "group"))

# Identify outliers (optional; only for highlighting, but not excluding)
plot_data_outliers <- plot_data %>%
  filter(aspl_values > 20 & type == "Political Interest")  # Outliers only for Political Interest above 20

# Recalculate confidence intervals (without filtering out outliers)
plot_data_summary_filtered <- plot_data %>%
  group_by(type, group) %>%
  summarise(
    mean_aspl = mean(aspl_values, na.rm = TRUE),
    ci_lower = quantile(aspl_values, 0.025, na.rm = TRUE),  # Asymmetrical 90% CI lower bound (2.5th percentile)
    ci_upper = quantile(aspl_values, 0.925, na.rm = TRUE),  # Asymmetrical 90% CI upper bound (92.5th percentile)
    .groups = "drop"
  )

# Create the violin plot with boxplot inside, horizontal error bars, and correct facets
aspl_violin_plot <- ggplot(plot_data, aes(y = group, x = aspl_values, fill = group)) +
  geom_violin(scale = "count", width = 0.6) +  # Violin plot
  geom_boxplot(width = 0.1, position = position_dodge(width = 0.9), alpha = 0.6) +  # Add a boxplot inside the violin plot
  geom_errorbar(data = plot_data_summary_filtered, aes(x = mean_aspl, xmin = ci_lower, xmax = ci_upper), 
                width = 0.2, linewidth = 0.7, color = "black") +  # Horizontal error bars based on data
  geom_point(data = plot_data_outliers, aes(x = aspl_values, y = group), color = "red", size = 2) +  # Outliers as red dots
  theme_ipsum() +  # Apply theme
  labs(title = "ASPL Distribution by Group with 90% CIs", x = "ASPL", y = NULL) +  # Adjust labels
  facet_wrap(~ type, scales = "free_x") +  # Facet by type (Education vs Political Interest), with free x-axis scales
  scale_fill_manual(values = c("low" = "#966FD6B3", "high" = "#008B8BB3")) +  # Custom colors for groups
  scale_x_continuous(limits = c(NA, 20), expand = expansion(mult = 0.05)) +  # Restrict x-axis to max 20 for Political Interest
  theme(
    axis.title.y = element_text(),  # Keep the axis title consistent for the y-axis
    legend.position = "none",  # Suppress the legend
    plot.title = element_text(hjust = 0.5),  # Center the plot title
    panel.border = element_blank()  # Clean look without borders
  )

# Display the plot
print(aspl_violin_plot)

```

### R2 sum

```{r}
# Function to calculate the average R² with bootstrapped 95% CIs
r2_from_boots_with_ci <- function(df_boot) {
  
  # Extract the matrices
  matrix_list <- lapply(1:10000, function(i) {
    df_boot[["boots"]][[i]][["graph"]]
  })
  
  # Ensure that all values in the matrices are non-negative by taking the absolute value
  matrix_list <- lapply(matrix_list, function(mat) {
    mat <- abs(mat)  # Take the absolute value of all matrix elements
    return(mat)
  })
  
  # Calculate R² for each matrix as sum of non-zero edges divided by 2 (for symmetry)
  r2_values <- sapply(matrix_list, function(mat) {
    node_sums <- apply(mat, 2, function(col) {
      non_zero_edges <- col[col != 0]  # Exclude zero edges
      return(sum(non_zero_edges))
    })
    
    mean_r2 <- mean(node_sums) / 2  # Adjust for symmetry
    return(mean_r2)
  })
  
  # Calculate mean and standard deviation of R² values for this group
  mean_r2 <- mean(r2_values, na.rm = TRUE)
  sd_r2 <- sd(r2_values, na.rm = TRUE)
  
  # Exclude outliers: keep only values within ±3 standard deviations from the mean for this group
  r2_values_filtered <- r2_values#[r2_values >= (mean_r2 - 3 * sd_r2) & 
                                 # r2_values <= (mean_r2 + 3 * sd_r2)]
  
  # Calculate 95% bootstrapped confidence intervals using quantiles
  ci_lower <- quantile(r2_values_filtered, 0.025, na.rm = TRUE)  # 2.5th percentile for lower bound
  ci_upper <- quantile(r2_values_filtered, 0.925, na.rm = TRUE)  # 92.5th percentile for upper bound

  
  # Return the R² values with outliers removed along with CIs and mean
  return(list(mean_r2 = mean(r2_values_filtered, na.rm = TRUE),
              ci_lower = ci_lower, 
              ci_upper = ci_upper,
              r2_values = r2_values_filtered))  # Also return the filtered values for box plot
}

# Apply this function to datasets for political interest and education
r2_pint_l_2_1_pc <- r2_from_boots_with_ci(df.boot_pint_l_2_1_pc)
r2_pint_h_2_1_pc <- r2_from_boots_with_ci(df.boot_pint_h_2_1_pc)

r2_educ_l_pc <- r2_from_boots_with_ci(df.boot_educ_l_pc)
r2_educ_h_pc <- r2_from_boots_with_ci(df.boot_educ_h_pc)

# Prepare the data for box plot with R² values
plot_data <- data.frame(
  type = c(rep("pint", length(r2_pint_l_2_1_pc$r2_values)), rep("pint", length(r2_pint_h_2_1_pc$r2_values)),
           rep("educ", length(r2_educ_l_pc$r2_values)), rep("educ", length(r2_educ_h_pc$r2_values))),
  group = c(rep("low", length(r2_pint_l_2_1_pc$r2_values)), rep("high", length(r2_pint_h_2_1_pc$r2_values)),
            rep("low", length(r2_educ_l_pc$r2_values)), rep("high", length(r2_educ_h_pc$r2_values))),
  r2_values = c(r2_pint_l_2_1_pc$r2_values, r2_pint_h_2_1_pc$r2_values, 
                r2_educ_l_pc$r2_values, r2_educ_h_pc$r2_values),
  mean_r2 = c(rep(r2_pint_l_2_1_pc$mean_r2, length(r2_pint_l_2_1_pc$r2_values)),
              rep(r2_pint_h_2_1_pc$mean_r2, length(r2_pint_h_2_1_pc$r2_values)),
              rep(r2_educ_l_pc$mean_r2, length(r2_educ_l_pc$r2_values)),
              rep(r2_educ_h_pc$mean_r2, length(r2_educ_h_pc$r2_values))),
  ci_lower = c(rep(r2_pint_l_2_1_pc$ci_lower, length(r2_pint_l_2_1_pc$r2_values)),
               rep(r2_pint_h_2_1_pc$ci_lower, length(r2_pint_h_2_1_pc$r2_values)),
               rep(r2_educ_l_pc$ci_lower, length(r2_educ_l_pc$r2_values)),
               rep(r2_educ_h_pc$ci_lower, length(r2_educ_h_pc$r2_values))),
  ci_upper = c(rep(r2_pint_l_2_1_pc$ci_upper, length(r2_pint_l_2_1_pc$r2_values)),
               rep(r2_pint_h_2_1_pc$ci_upper, length(r2_pint_h_2_1_pc$r2_values)),
               rep(r2_educ_l_pc$ci_upper, length(r2_educ_l_pc$r2_values)),
               rep(r2_educ_h_pc$ci_upper, length(r2_educ_h_pc$r2_values)))
)

# Create the violin plot and add CIs using geom_errorbar
r2_plot <- ggplot(plot_data, aes(y = group, x = r2_values, fill = group)) +  # Horizontal violins
  geom_violin(scale = "count", width = 0.6) +  # Use violin plot to represent distribution
  geom_boxplot(width = 0.1, position = position_dodge(width = 0.9), alpha = 0.6) +  # Boxplot inside the violin
  geom_errorbar(aes(x = mean_r2, xmin = ci_lower, xmax = ci_upper),  # Horizontal error bars
                width = 0.2, linewidth = 0.7, color = "black") +  # Add CI error bars
  scale_fill_manual(values = c("low" = "#966FD6B3", "high" = "#008B8BB3")) +  # Custom color scheme
  labs(title = "R² Distribution by Group with 90% CIs", x = "R²", y = NULL, fill = "Group") +  # Adjust labels and title
  facet_wrap(~ type, labeller = as_labeller(c("educ" = "Education", "pint" = "Political Interest")), scales = "fixed") +  # Set panel labels and equal x-axis
  theme_ipsum() +  # Apply the theme for consistent styling
  theme(
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),  # Center and enlarge title
    axis.title.y = element_text(),  # Keep the axis title consistent for the y-axis
    legend.position = "none",  # Suppress the legend
    panel.border = element_blank()  # Clean look without borders
  )

# Display the plot
print(r2_plot)

```


### Figure for H1 and H2

```{r}
# Save
Figure_3 <- (aspl_violin_plot / facet_r2_plot / r2_plot) +
  plot_layout(heights = c(1, 2, 1))

ggsave(here("Output", "Article", "Figure_3.jpg"), Figure_3, width = 12, height = 16, dpi = 300)
```


## H3

### Mnm of educ and pint

```{r}
# Data prep
mnm_educ_data = IPBS %>% 
  select(L_R: ukrai, educ_cat) %>% 
  mutate(educ_cat = case_when(
    educ_cat == "Degree or more" ~ 1,
    educ_cat == "Less than university" ~ 0)) %>% 
  as.matrix()

mnm_pint_data = IPBS %>% 
  select(L_R: ukrai, pol_int) %>% 
  mutate(pol_int = case_when(
    pol_int %in% c(1,2) ~ 0,
    pol_int %in% c(3,4) ~ 1
  )) %>% 
  as.matrix()

# mnms
mnm_educ = mgm(mnm_educ_data, type = c(rep("g", 19), "c"), level = c(rep(1, 19), 2),
               moderators = 20, lambdaSel = "EBIC", ruleReg = "OR", binarySign = T)

mnm_pint = mgm(mnm_pint_data, type = c(rep("g", 19), "c"), level = c(rep(1, 19), 2),
               moderators = 20, lambdaSel = "EBIC", ruleReg = "OR", binarySign = T)

# Inspecting interactions
mnm_pint$interactions$indicator #61 pairwise, 23 moderations
mnm_educ$interactions$indicator #72 pairwise, 9 moderations


mnm_educ$interactions$indicator
```

### mnm network plot for vote

```{r}
#Enlarge objects
shortnames = c("L_R","PTV_PD","PTV_FI","PTV_L","PTV_M5S","PTV_FDI","adopt","abort","eutha","marria","redis","flat_t","m_wage","cit_in","globa",     
                "immig","big_go","pub_pri","ukrai","vote_cat")

Totalgroup_comm <- list(
  "Symbolic" = c(1:6),
  "Operational" = c(7:19),
  "Vote choice" = c(20)
)

Totalgroup_cols <- c("#966FD6B3", "#008B8BB3", "#FFFF00")  

# Data prep
mnm_vote_data <- IPBS %>% 
  select(L_R:ukrai, vote_cat) %>% 
  mutate(vote_cat = case_when(
    vote_cat == "Sin" ~ 0,
    vote_cat == "M5S" ~ NA,  # This group will be ignored in the plotting
    vote_cat == "Dx" ~ 1
  )) %>% 
  na.omit() %>% 
  as.matrix()

# Fit the mgm model
mnm_vote <- mgm(
  data = mnm_vote_data,
  type = c(rep("g", 19), "c"),  
  level = c(rep(1, 19), 2),     
  moderators = 20,              
  lambdaSel = "EBIC",           
  ruleReg = "OR",
  binarySign = T
)

# Conditioning the model on each level of vote_cat (Left and Right only)
cond0 <- condition(object = mnm_vote, values = list('20' = 0))  # Left (Sin)
cond1 <- condition(object = mnm_vote, values = list('20' = 1))  # Right (Dx)

# Initial plots to generate layouts
Graph_cond_0 <- qgraph(cond0$pairwise$wadj)
Graph_cond_1 <- qgraph(cond1$pairwise$wadj)

# Multiplot for Left and Right only
jpeg(here("Output", "Supplement", "mnm_vote_left_right.jpg"), 
     height = 4000, width = 8000, quality = 1000)  # Adjust image size as needed

# Create a common layout based on the two conditions
L <- averageLayout(Graph_cond_0, Graph_cond_1, layout = "spring")

# Matrix layout for the graphs (1 row, 2 columns)
lmat <- matrix(1:2, 1, 2)

# Start plotting
layout(lmat, width = c(1, 1))

# Generate plots for Left (Sin)
set.seed(1)
Graph_cond_0 <- qgraph(
  cond0$pairwise$wadj, layout = L, fade = TRUE,  # Enable edge fading
  labels = shortnames, vTrans = 255,  # Transparency setting
  groups = Totalgroup_comm,  
  color = Totalgroup_cols,  
  legend = FALSE, title = "Left", title.cex = 12,
  edge.color = cond0$pairwise$edgecolor_cb,  # Ensure edge colors reflect the weights
  borders = TRUE, vsize = 10, esize = 15, 
  edge.alpha = TRUE,  # Use edge.alpha to control transparency based on edge weight
  cut = 0.05,  # Set a lower cut-off threshold
  alpha = 0.7,  # Explicit alpha control to help edge fading
  maximum = max(c(cond0$pairwise$wadj, cond1$pairwise$wadj))  # Consistent scaling across plots
)

# Generate plots for Right (Dx)
set.seed(1)
Graph_cond_1 <- qgraph(
  cond1$pairwise$wadj, layout = L, fade = TRUE,  # Enable edge fading
  labels = shortnames,  
  groups = Totalgroup_comm, 
  color = Totalgroup_cols, 
  legend = FALSE, title = "Right", title.cex = 12,
  edge.color = cond1$pairwise$edgecolor_cb,  # Ensure edge colors reflect the weights
  borders = TRUE, vsize = 10, esize = 15, 
  edge.alpha = TRUE,  # Use edge.alpha to control transparency based on edge weight
  cut = 0.05,  # Set a lower cut-off threshold
  alpha = 0.7,  # Explicit alpha control to help edge fading
  maximum = max(c(cond0$pairwise$wadj, cond1$pairwise$wadj))  # Consistent scaling across plots
)

# Finish and save the plot
dev.off()

```


### Figure_4 plot

#### Vote

```{r}
# Extract signed interactions
#mnm_vote$interactions$indicator[[2]]

edge_1_2 = showInteraction(object = mnm_vote, int = c(1,2,20)) 
edge_1_2 = edge_1_2$edgeweight*edge_1_2$sign

edge_1_19 = showInteraction(object = mnm_vote, int = c(1,19,20)) 
edge_1_19 = edge_1_19$edgeweight*edge_1_19$sign

edge_2_5 = showInteraction(object = mnm_vote, int = c(2,5,20)) 
edge_2_5 = edge_2_5$edgeweight*edge_2_5$sign

edge_2_6 = showInteraction(object = mnm_vote, int = c(2,6,20)) 
edge_2_6 = edge_2_6$edgeweight*edge_2_6$sign

edge_2_7 = showInteraction(object = mnm_vote, int = c(2,7,20)) 
edge_2_7 = edge_2_7$edgeweight*edge_2_7$sign

edge_2_15 = showInteraction(object = mnm_vote, int = c(2,15,20)) 
edge_2_15 = edge_2_15$edgeweight*edge_2_15$sign

edge_2_16 = showInteraction(object = mnm_vote, int = c(2,16,20)) 
edge_2_16 = edge_2_16$edgeweight*edge_2_16$sign

edge_2_17 = showInteraction(object = mnm_vote, int = c(2,17,20)) 
edge_2_17 = edge_2_17$edgeweight*edge_2_17$sign

edge_2_18 = showInteraction(object = mnm_vote, int = c(2,18,20)) 
edge_2_18 = edge_2_18$edgeweight*edge_2_18$sign

edge_3_5 = showInteraction(object = mnm_vote, int = c(3,5,20)) 
edge_3_5 = edge_3_5$edgeweight*edge_3_5$sign

edge_5_8 = showInteraction(object = mnm_vote, int = c(5,8,20)) 
edge_5_8 = edge_5_8$edgeweight*edge_5_8$sign

edge_5_17 = showInteraction(object = mnm_vote, int = c(5,17,20)) 
edge_5_17 = edge_5_17$edgeweight*edge_5_17$sign

edge_7_17 = showInteraction(object = mnm_vote, int = c(7,17,20)) 
edge_7_17 = edge_7_17$edgeweight*edge_7_17$sign

edge_8_9 = showInteraction(object = mnm_vote, int = c(8,9,20)) 
edge_8_9 = edge_8_9$edgeweight*edge_8_9$sign

edge_10_16 = showInteraction(object = mnm_vote, int = c(10,16,20)) 
edge_10_16 = edge_10_16$edgeweight*edge_10_16$sign

edge_13_17 = showInteraction(object = mnm_vote, int = c(13,17,20)) 
edge_13_17 = edge_13_17$edgeweight*edge_13_17$sign

edge_14_17 = showInteraction(object = mnm_vote, int = c(14,17,20)) 
edge_14_17 = edge_14_17$edgeweight*edge_14_17$sign

edge_16_17 = showInteraction(object = mnm_vote, int = c(16,17,20)) 
edge_16_17 = edge_16_17$edgeweight*edge_16_17$sign

#edgeweights
ew_1_2 = showInteraction(object = mnm_vote, int = c(1,2)) 
ew_1_2 = ew_1_2$edgeweight * ew_1_2$sign

ew_1_19 = showInteraction(object = mnm_vote, int = c(1,19)) 
ew_1_19 = ew_1_19$edgeweight * ew_1_19$sign

ew_2_5 = showInteraction(object = mnm_vote, int = c(2,5)) 
ew_2_5 = ew_2_5$edgeweight * ew_2_5$sign

ew_2_6 = showInteraction(object = mnm_vote, int = c(2,6)) 
ew_2_6 = ew_2_6$edgeweight * ew_2_6$sign

ew_2_7 = showInteraction(object = mnm_vote, int = c(2,7)) 
ew_2_7 = ew_2_7$edgeweight * ew_2_7$sign

ew_2_15 = showInteraction(object = mnm_vote, int = c(2,15)) 
ew_2_15 = ew_2_15$edgeweight * ew_2_15$sign

ew_2_16 = showInteraction(object = mnm_vote, int = c(2,16)) 
ew_2_16 = ew_2_16$edgeweight * ew_2_16$sign

ew_2_17 = showInteraction(object = mnm_vote, int = c(2,17)) 
ew_2_17 = ew_2_17$edgeweight * ew_2_17$sign

ew_2_18 = showInteraction(object = mnm_vote, int = c(2,18)) 
ew_2_18 = ew_2_18$edgeweight * ew_2_18$sign

ew_3_5 = showInteraction(object = mnm_vote, int = c(3,5)) 
ew_3_5 = ew_3_5$edgeweight * ew_3_5$sign

ew_5_8 = showInteraction(object = mnm_vote, int = c(5,8)) 
ew_5_8 = ew_5_8$edgeweight * ew_5_8$sign

ew_5_17 = showInteraction(object = mnm_vote, int = c(5,17)) 
ew_5_17 = ew_5_17$edgeweight * ew_5_17$sign

ew_7_17 = showInteraction(object = mnm_vote, int = c(7,17)) 
ew_7_17 = ew_7_17$edgeweight * ew_7_17$sign

ew_8_9 = showInteraction(object = mnm_vote, int = c(8,9)) 
ew_8_9 = ew_8_9$edgeweight * ew_8_9$sign

ew_10_16 = showInteraction(object = mnm_vote, int = c(10,16)) 
ew_10_16 = ew_10_16$edgeweight * ew_10_16$sign

ew_13_17 = showInteraction(object = mnm_vote, int = c(13,17)) 
ew_13_17 = ew_13_17$edgeweight * ew_13_17$sign

ew_14_17 = showInteraction(object = mnm_vote, int = c(14,17)) 
ew_14_17 = ew_14_17$edgeweight * ew_14_17$sign

ew_16_17 = showInteraction(object = mnm_vote, int = c(16,17)) 
ew_16_17 = ew_16_17$edgeweight * ew_16_17$sign
```


```{r}
# Store in a df
# Create an empty dataframe to store the results
signed_mod_vote <- data.frame(Node1 = integer(), Node2 = integer(), Node3 = integer(), 
                              SignedWeight = numeric(), EW_SignedWeight = numeric())

# List of edges (replace with the specific edges you've already created)
edges <- list(
  "edge_1_2", "edge_1_19", "edge_2_5", "edge_2_6", "edge_2_7", "edge_2_15", "edge_2_16", "edge_2_17",
  "edge_2_18", "edge_3_5", "edge_5_8", "edge_5_17", "edge_7_17", "edge_8_9", "edge_10_16", "edge_13_17",
  "edge_14_17", "edge_16_17"
)

# List of corresponding ew_* values for two-way interactions
ew_edges <- list(
  "ew_1_2", "ew_1_19", "ew_2_5", "ew_2_6", "ew_2_7", "ew_2_15", "ew_2_16", "ew_2_17",
  "ew_2_18", "ew_3_5", "ew_5_8", "ew_5_17", "ew_7_17", "ew_8_9", "ew_10_16", "ew_13_17",
  "ew_14_17", "ew_16_17"
)

# Corresponding node triples for each interaction
nodes <- list(
  c(1, 2, 20), c(1, 19, 20), c(2, 5, 20), c(2, 6, 20), c(2, 7, 20), c(2, 15, 20), c(2, 16, 20), c(2, 17, 20),
  c(2, 18, 20), c(3, 5, 20), c(5, 8, 20), c(5, 17, 20), c(7, 17, 20), c(8, 9, 20), c(10, 16, 20), c(13, 17, 20),
  c(14, 17, 20), c(16, 17, 20)
)

# Loop through each edge and append it to the dataframe
for (i in seq_along(edges)) {
  # Get the signed weight from the edge and ew objects
  signed_weight <- get(edges[[i]])
  ew_signed_weight <- get(ew_edges[[i]])
  
  # Append to the dataframe
  signed_mod_vote <- rbind(signed_mod_vote, 
                           data.frame(Node1 = nodes[[i]][1], 
                                      Node2 = nodes[[i]][2], 
                                      Node3 = nodes[[i]][3], 
                                      SignedWeight = signed_weight,
                                      EW_SignedWeight = ew_signed_weight))
}

# Recode Node1 and Node2 based on shortnames
signed_mod_vote <- signed_mod_vote %>%
  mutate(Node1 = shortnames[Node1],  # Recode Node1 based on shortnames
         Node2 = shortnames[Node2])

#clean 
signed_mod_vote <- signed_mod_vote %>%
  select(-Node3)

# Step 2: Create the predicted0 column (EW_SignedWeight + (SignedWeight * 0))
signed_mod_vote <- signed_mod_vote %>%
  mutate(predicted0 = EW_SignedWeight + (SignedWeight * 0))

# Step 3: Create the predicted1 column (EW_SignedWeight + (SignedWeight * 1))
signed_mod_vote <- signed_mod_vote %>%
  mutate(predicted1 = EW_SignedWeight + (SignedWeight * 1))

# melt cols
signed_mod_vote <- signed_mod_vote %>%
  mutate(Node = paste(Node1, Node2, sep = "-"))

```


#### educ

```{r}
# Extract signed interactions from mnm_educ

# For three-way interactions
edge_1_3 = showInteraction(object = mnm_educ, int = c(1, 3, 20))
edge_1_3 = edge_1_3$edgeweight * edge_1_3$sign

edge_2_5 = showInteraction(object = mnm_educ, int = c(2, 5, 20))
edge_2_5 = edge_2_5$edgeweight * edge_2_5$sign

edge_4_5 = showInteraction(object = mnm_educ, int = c(4, 5, 20))
edge_4_5 = edge_4_5$edgeweight * edge_4_5$sign

edge_4_8 = showInteraction(object = mnm_educ, int = c(4, 8, 20))
edge_4_8 = edge_4_8$edgeweight * edge_4_8$sign

edge_6_12 = showInteraction(object = mnm_educ, int = c(6, 12, 20))
edge_6_12 = edge_6_12$edgeweight * edge_6_12$sign

edge_7_9 = showInteraction(object = mnm_educ, int = c(7, 9, 20))
edge_7_9 = edge_7_9$edgeweight * edge_7_9$sign

edge_7_14 = showInteraction(object = mnm_educ, int = c(7, 14, 20))
edge_7_14 = edge_7_14$edgeweight * edge_7_14$sign

edge_12_15 = showInteraction(object = mnm_educ, int = c(12, 15, 20))
edge_12_15 = edge_12_15$edgeweight * edge_12_15$sign

edge_14_18 = showInteraction(object = mnm_educ, int = c(14, 18, 20))
edge_14_18 = edge_14_18$edgeweight * edge_14_18$sign

# For two-way interactions (edgeweights)
ew_1_3 = showInteraction(object = mnm_educ, int = c(1, 3))
ew_1_3 = ew_1_3$edgeweight * ew_1_3$sign

ew_2_5 = showInteraction(object = mnm_educ, int = c(2, 5))
ew_2_5 = ew_2_5$edgeweight * ew_2_5$sign

ew_4_5 = showInteraction(object = mnm_educ, int = c(4, 5))
ew_4_5 = ew_4_5$edgeweight * ew_4_5$sign

ew_4_8 = showInteraction(object = mnm_educ, int = c(4, 8))
ew_4_8 = ew_4_8$edgeweight * ew_4_8$sign

ew_6_12 = showInteraction(object = mnm_educ, int = c(6, 12))
ew_6_12 = ew_6_12$edgeweight * ew_6_12$sign

ew_7_9 = showInteraction(object = mnm_educ, int = c(7, 9))
ew_7_9 = ew_7_9$edgeweight * ew_7_9$sign

ew_7_14 = showInteraction(object = mnm_educ, int = c(7, 14))
ew_7_14 = ew_7_14$edgeweight * ew_7_14$sign

ew_12_15 = showInteraction(object = mnm_educ, int = c(12, 15))
ew_12_15 = ew_12_15$edgeweight * ew_12_15$sign

ew_14_18 = showInteraction(object = mnm_educ, int = c(14, 18))
ew_14_18 = ew_14_18$edgeweight * ew_14_18$sign

```

```{r}
# Store in a df
# Create an empty dataframe to store the results
signed_mod_educ <- data.frame(Node1 = integer(), Node2 = integer(), Node3 = integer(), 
                              SignedWeight = numeric(), EW_SignedWeight = numeric())

# List of edges (replace with the specific edges you've already created)
edges <- list(
  "edge_1_3", "edge_2_5", "edge_4_5", "edge_4_8", "edge_6_12", "edge_7_9", "edge_7_14", 
  "edge_12_15", "edge_14_18"
)

# List of corresponding ew_* values for two-way interactions
ew_edges <- list(
  "ew_1_3", "ew_2_5", "ew_4_5", "ew_4_8", "ew_6_12", "ew_7_9", "ew_7_14", 
  "ew_12_15", "ew_14_18"
)

# Corresponding node triples for each interaction
nodes <- list(
  c(1, 3, 20), c(2, 5, 20), c(4, 5, 20), c(4, 8, 20), c(6, 12, 20), c(7, 9, 20), 
  c(7, 14, 20), c(12, 15, 20), c(14, 18, 20)
)

# Loop through each edge and append it to the dataframe
for (i in seq_along(edges)) {
  # Get the signed weight from the edge and ew objects
  signed_weight <- get(edges[[i]])
  ew_signed_weight <- get(ew_edges[[i]])
  
  # Append to the dataframe
  signed_mod_educ <- rbind(signed_mod_educ, 
                           data.frame(Node1 = nodes[[i]][1], 
                                      Node2 = nodes[[i]][2], 
                                      Node3 = nodes[[i]][3], 
                                      SignedWeight = signed_weight,
                                      EW_SignedWeight = ew_signed_weight))
}

# Recode Node1 and Node2 based on shortnames
signed_mod_educ <- signed_mod_educ %>%
  mutate(Node1 = shortnames[Node1],  # Recode Node1 based on shortnames
         Node2 = shortnames[Node2])

# Remove Node3
signed_mod_educ <- signed_mod_educ %>%
  select(-Node3)

# Step 2: Create the predicted0 column (EW_SignedWeight + (SignedWeight * 0))
signed_mod_educ <- signed_mod_educ %>%
  mutate(predicted0 = EW_SignedWeight + (SignedWeight * 0))

# Step 3: Create the predicted1 column (EW_SignedWeight + (SignedWeight * 1))
signed_mod_educ <- signed_mod_educ %>%
  mutate(predicted1 = EW_SignedWeight + (SignedWeight * 1))

# Step 4: Create the Node column combining Node1 and Node2
signed_mod_educ <- signed_mod_educ %>%
  mutate(Node = paste(Node1, Node2, sep = "-"))
```


#### pint

```{r}
# Extract signed interactions for mnm_pint
edge_1_11 = showInteraction(object = mnm_pint, int = c(1,11,20)) 
edge_1_11 = edge_1_11$edgeweight * edge_1_11$sign

edge_1_12 = showInteraction(object = mnm_pint, int = c(1,12,20)) 
edge_1_12 = edge_1_12$edgeweight * edge_1_12$sign

edge_1_18 = showInteraction(object = mnm_pint, int = c(1,18,20)) 
edge_1_18 = edge_1_18$edgeweight * edge_1_18$sign

edge_2_16 = showInteraction(object = mnm_pint, int = c(2,16,20)) 
edge_2_16 = edge_2_16$edgeweight * edge_2_16$sign

edge_3_4 = showInteraction(object = mnm_pint, int = c(3,4,20)) 
edge_3_4 = edge_3_4$edgeweight * edge_3_4$sign

edge_3_8 = showInteraction(object = mnm_pint, int = c(3,8,20)) 
edge_3_8 = edge_3_8$edgeweight * edge_3_8$sign

edge_4_8 = showInteraction(object = mnm_pint, int = c(4,8,20)) 
edge_4_8 = edge_4_8$edgeweight * edge_4_8$sign

edge_4_12 = showInteraction(object = mnm_pint, int = c(4,12,20)) 
edge_4_12 = edge_4_12$edgeweight * edge_4_12$sign

edge_4_13 = showInteraction(object = mnm_pint, int = c(4,13,20)) 
edge_4_13 = edge_4_13$edgeweight * edge_4_13$sign

edge_5_14 = showInteraction(object = mnm_pint, int = c(5,14,20)) 
edge_5_14 = edge_5_14$edgeweight * edge_5_14$sign

edge_5_19 = showInteraction(object = mnm_pint, int = c(5,19,20)) 
edge_5_19 = edge_5_19$edgeweight * edge_5_19$sign

edge_6_15 = showInteraction(object = mnm_pint, int = c(6,15,20)) 
edge_6_15 = edge_6_15$edgeweight * edge_6_15$sign

edge_7_15 = showInteraction(object = mnm_pint, int = c(7,15,20)) 
edge_7_15 = edge_7_15$edgeweight * edge_7_15$sign

edge_8_12 = showInteraction(object = mnm_pint, int = c(8,12,20)) 
edge_8_12 = edge_8_12$edgeweight * edge_8_12$sign

edge_10_16 = showInteraction(object = mnm_pint, int = c(10,16,20)) 
edge_10_16 = edge_10_16$edgeweight * edge_10_16$sign

edge_11_16 = showInteraction(object = mnm_pint, int = c(11,16,20)) 
edge_11_16 = edge_11_16$edgeweight * edge_11_16$sign

edge_11_17 = showInteraction(object = mnm_pint, int = c(11,17,20)) 
edge_11_17 = edge_11_17$edgeweight * edge_11_17$sign

edge_12_17 = showInteraction(object = mnm_pint, int = c(12,17,20)) 
edge_12_17 = edge_12_17$edgeweight * edge_12_17$sign

edge_13_17 = showInteraction(object = mnm_pint, int = c(13,17,20)) 
edge_13_17 = edge_13_17$edgeweight * edge_13_17$sign

edge_14_15 = showInteraction(object = mnm_pint, int = c(14,15,20)) 
edge_14_15 = edge_14_15$edgeweight * edge_14_15$sign

edge_14_18 = showInteraction(object = mnm_pint, int = c(14,18,20)) 
edge_14_18 = edge_14_18$edgeweight * edge_14_18$sign

edge_15_19 = showInteraction(object = mnm_pint, int = c(15,19,20)) 
edge_15_19 = edge_15_19$edgeweight * edge_15_19$sign

edge_16_19 = showInteraction(object = mnm_pint, int = c(16,19,20)) 
edge_16_19 = edge_16_19$edgeweight * edge_16_19$sign

# Extract edge weights (ew_) for two-way interactions
ew_1_11 = showInteraction(object = mnm_pint, int = c(1,11)) 
ew_1_11 = ew_1_11$edgeweight * ew_1_11$sign

ew_1_12 = showInteraction(object = mnm_pint, int = c(1,12)) 
ew_1_12 = ew_1_12$edgeweight * ew_1_12$sign

ew_1_18 = showInteraction(object = mnm_pint, int = c(1,18)) 
ew_1_18 = ew_1_18$edgeweight * ew_1_18$sign

ew_2_16 = showInteraction(object = mnm_pint, int = c(2,16)) 
ew_2_16 = ew_2_16$edgeweight * ew_2_16$sign

ew_3_4 = showInteraction(object = mnm_pint, int = c(3,4)) 
ew_3_4 = ew_3_4$edgeweight * ew_3_4$sign

ew_3_8 = showInteraction(object = mnm_pint, int = c(3,8)) 
ew_3_8 = ew_3_8$edgeweight * ew_3_8$sign

ew_4_8 = showInteraction(object = mnm_pint, int = c(4,8)) 
ew_4_8 = ew_4_8$edgeweight * ew_4_8$sign

ew_4_12 = showInteraction(object = mnm_pint, int = c(4,12)) 
ew_4_12 = ew_4_12$edgeweight * ew_4_12$sign

ew_4_13 = showInteraction(object = mnm_pint, int = c(4,13)) 
ew_4_13 = ew_4_13$edgeweight * ew_4_13$sign

ew_5_14 = showInteraction(object = mnm_pint, int = c(5,14)) 
ew_5_14 = ew_5_14$edgeweight * ew_5_14$sign

ew_5_19 = showInteraction(object = mnm_pint, int = c(5,19)) 
ew_5_19 = ew_5_19$edgeweight * ew_5_19$sign

ew_6_15 = showInteraction(object = mnm_pint, int = c(6,15)) 
ew_6_15 = ew_6_15$edgeweight * ew_6_15$sign

ew_7_15 = showInteraction(object = mnm_pint, int = c(7,15)) 
ew_7_15 = ew_7_15$edgeweight * ew_7_15$sign

ew_8_12 = showInteraction(object = mnm_pint, int = c(8,12)) 
ew_8_12 = ew_8_12$edgeweight * ew_8_12$sign

ew_10_16 = showInteraction(object = mnm_pint, int = c(10,16)) 
ew_10_16 = ew_10_16$edgeweight * ew_10_16$sign

ew_11_16 = showInteraction(object = mnm_pint, int = c(11,16)) 
ew_11_16 = ew_11_16$edgeweight * ew_11_16$sign

ew_11_17 = showInteraction(object = mnm_pint, int = c(11,17)) 
ew_11_17 = ew_11_17$edgeweight * ew_11_17$sign

ew_12_17 = showInteraction(object = mnm_pint, int = c(12,17)) 
ew_12_17 = ew_12_17$edgeweight * ew_12_17$sign

ew_13_17 = showInteraction(object = mnm_pint, int = c(13,17)) 
ew_13_17 = ew_13_17$edgeweight * ew_13_17$sign

ew_14_15 = showInteraction(object = mnm_pint, int = c(14,15)) 
ew_14_15 = ew_14_15$edgeweight * ew_14_15$sign

ew_14_18 = showInteraction(object = mnm_pint, int = c(14,18)) 
ew_14_18 = ew_14_18$edgeweight * ew_14_18$sign

ew_15_19 = showInteraction(object = mnm_pint, int = c(15,19)) 
ew_15_19 = ew_15_19$edgeweight * ew_15_19$sign

ew_16_19 = showInteraction(object = mnm_pint, int = c(16,19)) 
ew_16_19 = ew_16_19$edgeweight * ew_16_19$sign
```

```{r}
# Store in a df
# Create an empty dataframe to store the results
signed_mod_pint <- data.frame(Node1 = integer(), Node2 = integer(), Node3 = integer(), 
                              SignedWeight = numeric(), EW_SignedWeight = numeric())

# List of edges based on new interactions in mnm_pint
edges <- list(
  "edge_1_11", "edge_1_12", "edge_1_18", "edge_2_16", "edge_3_4", "edge_3_8", 
  "edge_4_8", "edge_4_12", "edge_4_13", "edge_5_14", "edge_5_19", "edge_6_15", 
  "edge_7_15", "edge_8_12", "edge_10_16", "edge_11_16", "edge_11_17", "edge_12_17",
  "edge_13_17", "edge_14_15", "edge_14_18", "edge_15_19", "edge_16_19"
)

# List of corresponding ew_* values for two-way interactions
ew_edges <- list(
  "ew_1_11", "ew_1_12", "ew_1_18", "ew_2_16", "ew_3_4", "ew_3_8", 
  "ew_4_8", "ew_4_12", "ew_4_13", "ew_5_14", "ew_5_19", "ew_6_15", 
  "ew_7_15", "ew_8_12", "ew_10_16", "ew_11_16", "ew_11_17", "ew_12_17",
  "ew_13_17", "ew_14_15", "ew_14_18", "ew_15_19", "ew_16_19"
)

# Corresponding node triples for each interaction
nodes <- list(
  c(1, 11, 20), c(1, 12, 20), c(1, 18, 20), c(2, 16, 20), c(3, 4, 20), c(3, 8, 20), 
  c(4, 8, 20), c(4, 12, 20), c(4, 13, 20), c(5, 14, 20), c(5, 19, 20), c(6, 15, 20), 
  c(7, 15, 20), c(8, 12, 20), c(10, 16, 20), c(11, 16, 20), c(11, 17, 20), c(12, 17, 20),
  c(13, 17, 20), c(14, 15, 20), c(14, 18, 20), c(15, 19, 20), c(16, 19, 20)
)

# Loop through each edge and append it to the dataframe
for (i in seq_along(edges)) {
  # Get the signed weight from the edge and ew objects
  signed_weight <- get(edges[[i]])
  ew_signed_weight <- get(ew_edges[[i]])
  
  # Append to the dataframe
  signed_mod_pint <- rbind(signed_mod_pint, 
                           data.frame(Node1 = nodes[[i]][1], 
                                      Node2 = nodes[[i]][2], 
                                      Node3 = nodes[[i]][3], 
                                      SignedWeight = signed_weight,
                                      EW_SignedWeight = ew_signed_weight))
}

# Recode Node1 and Node2 based on shortnames
signed_mod_pint <- signed_mod_pint %>%
  mutate(Node1 = shortnames[Node1],  # Recode Node1 based on shortnames
         Node2 = shortnames[Node2])

#clean 
signed_mod_pint <- signed_mod_pint %>%
  select(-Node3)

# Step 2: Create the predicted0 column (EW_SignedWeight + (SignedWeight * 0))
signed_mod_pint <- signed_mod_pint %>%
  mutate(predicted0 = EW_SignedWeight + (SignedWeight * 0))

# Step 3: Create the predicted1 column (EW_SignedWeight + (SignedWeight * 1))
signed_mod_pint <- signed_mod_pint %>%
  mutate(predicted1 = EW_SignedWeight + (SignedWeight * 1))

# melt cols
signed_mod_pint <- signed_mod_pint %>%
  mutate(Node = paste(Node1, Node2, sep = "-"))

```


##### Final plot

```{r}
# Data manag

# Add a 'moderator' column to each dataframe
signed_mod_pint <- signed_mod_pint %>%
  mutate(moderator = "pint")

signed_mod_educ <- signed_mod_educ %>%
  mutate(moderator = "educ")

signed_mod_vote <- signed_mod_vote %>%
  mutate(moderator = "vote")

# Select the required columns (Node, predicted0, predicted1, moderator)
signed_mod_pint <- signed_mod_pint %>%
  select(Node, predicted0, predicted1, moderator)

signed_mod_educ <- signed_mod_educ %>%
  select(Node, predicted0, predicted1, moderator)

signed_mod_vote <- signed_mod_vote %>%
  select(Node, predicted0, predicted1, moderator)

# Combine the three dataframes into one
mod_merged <- bind_rows(signed_mod_pint, signed_mod_educ, signed_mod_vote)%>%
  mutate(abs_diff = abs(predicted0) - abs(predicted1))

```

```{r}
# Plot supplement

# Plot the graph with facet wrap by moderator
plot_mod_merged <- ggplot(mod_merged) +
  # Plot predicted0 with color #966FD6B3
  geom_point(aes(x = Node, y = predicted0, color = "Predicted 0"), size = 3) +
  
  # Plot predicted1 with color #008B8BB3
  geom_point(aes(x = Node, y = predicted1, color = "Predicted 1"), size = 3) +
  
  # Segment lines between the two points (predicted0 and predicted1)
  geom_segment(aes(x = Node, xend = Node, y = predicted0, yend = predicted1), color = "grey") +
  
  coord_flip() +  # Flip the axes
  
  # Customize the color scale
  scale_color_manual(values = c("Predicted 0" = "#966FD6B3", "Predicted 1" = "#008B8BB3")) +
  
  # Facet by moderator
  facet_wrap(~ moderator, scales = "free_y") +  # Ensure facets by moderator
  
  # Apply the theme
  theme_ipsum() +
  theme(
    legend.position = "bottom",  # Move legend to the bottom
    axis.title.y = element_text(size = 14, face = "bold"),
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),  # Adjust title size
    legend.title = element_text(size = 12, face = "bold")
  ) +
  
  # Add labels and title
  xlab("") +
  ylab("Signed Weight") +
  ggtitle("Predicted Signed Weights for Interactions by Moderator")

# Display the plot
print(plot_mod_merged)

ggsave(here("Output", "Supplement", "Moderation_coeff_full.jpg"), plot_mod_merged, width = 12, height = 12, dpi = 300)

```

```{r}
# Filtered plot: Article 

mod_merged_filtered <- mod_merged %>%
  filter(abs_diff < -0.03) %>%
  arrange(desc(predicted1))  # 1. Order by descending level of predicted1

# Plot the graph with facet wrap by moderator and filtered data
plot_mod_merged_filtered <- ggplot(mod_merged_filtered) +
  # Plot predicted0 with color #966FD6B3
  geom_point(aes(x = Node, y = predicted0, color = "Low group (Left)"), size = 3) +
  
  # Plot predicted1 with color #008B8BB3
  geom_point(aes(x = Node, y = predicted1, color = "High group (Right)"), size = 3) +
  
  # Segment lines between the two points (predicted0 and predicted1)
  geom_segment(aes(x = Node, xend = Node, y = predicted0, yend = predicted1), color = "grey") +
  
  # Add a reference line at x = 0
  geom_hline(yintercept = 0, color = "black", linetype = "dashed") +  # 4. Reference line
  
  coord_flip() +  # Flip the axes
  
  # Customize the color scale
  scale_color_manual(values = c("Low group (Left)" = "#966FD6B3", "High group (Right)" = "#008B8BB3")) +
  
  # Facet by moderator with specific panel labels
  facet_wrap(~ moderator, scales = "free_y", 
             labeller = as_labeller(c("pint" = "Political Interest", "educ" = "Education", "vote" = "Vote choice"))) +  # 3. Custom panel labels
  
  # Apply the theme
  theme_ipsum() +
  theme(
    legend.position = "bottom",  # Move legend to the bottom
    axis.title.y = element_text(size = 14, face = "bold"),
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),  # Adjust title size
    legend.title = element_text(size = 12, face = "bold")
  ) +
  
  # Add labels and title
  xlab("") +
  ylab("Edge Weight") +
  ggtitle("Edge Weights of Most Important Moderations, by Moderator")

# Display the plot
ggsave(here("Output", "Article", "Figure_4.jpg"), plot_mod_merged_filtered, width = 12, height = 8, dpi = 300)

```


# OLD

# Network descriptives
This code replicates descriptives of the networks used throughout the article

```{r}
#Figure 1

## Min edge weight
min_fig1 = att_net %>% 
  as.vector() %>%
  min()

## Max edge weight
max_fig1 = att_net %>% 
  as.vector() 
max_fig1 = max_fig1[max_fig1 != 1]
max_fig1 = max_fig1 %>%
 max()


## Node strength
strength_fig1 = centrality(att_net)
min_st_fig1 = min(strength_fig1$OutDegree)
max_st_fig1 = max(strength_fig1$OutDegree)

## Constraint
const_fig1 = mean(att_net)

## N° of zero cells
zerofig1 = sum(att_net <= 0.001)

## N° of non zero edges
nonzerofig1 = sum(att_net != 0)
```

```{r}
#Figure 2

## Point estimate and ci of each subgroup
mcon_pint_summary
mcon_edu_summary
```

```{r}
#Figure 3

## N° of non zero edges
n_left = (sum(vote_l_data_net != 0))/2
n_mov = (sum(vote_m_data_net != 0))/2
n_right = (sum(vote_r_data_net != 0))/2


## Density of each plot (Sum of the Absolute Value of Each Cell of a Matrix)
d_left = sum(abs(vote_l_data_net))
d_mov = sum(abs(vote_m_data_net))
d_right = sum(abs(vote_r_data_net))

```

```{r}
#NCT

## N° edges differing between each network pair
nnct_rm =  sum(input_NCTgraph_r_m != 0)
nnct_lr =  sum(input_NCTgraph_l_r != 0)
nnct_lm =  sum(input_NCTgraph_l_m != 0)

max_rm = max(input_NCTgraph_r_m)
max_lr = max(input_NCTgraph_l_r)
max_lm =  max(input_NCTgraph_l_m)
```

```{r}
#Figure 4

## average value of absolute edge weight in each vote bel syst (NON 0)
#left
avg_edg_l = vote_l_data_net %>% 
  abs() %>% 
  as.vector()

avg_edg_l = avg_edg_l[avg_edg_l != 0]
avg_edg_l = avg_edg_l[avg_edg_l != 1]

avg_edg_l = mean(avg_edg_l)

#right
avg_edg_m = vote_m_data_net %>% 
  abs() %>% 
  as.vector()

avg_edg_m = avg_edg_m[avg_edg_m != 0]
avg_edg_m = avg_edg_m[avg_edg_m != 1]

avg_edg_m = mean(avg_edg_m)

#Mov
avg_edg_r = vote_r_data_net %>% 
  abs() %>% 
  as.vector()

avg_edg_r = avg_edg_r[avg_edg_r != 0]
avg_edg_r = avg_edg_r[avg_edg_r != 1]

avg_edg_r = mean(avg_edg_r)

# Number of edges differing between matrices
ndiff_rm = (sum(vote_r_data_net != vote_m_data_net))/2
ndiff_lr = (sum(vote_l_data_net != vote_r_data_net))/2
ndiff_lm = (sum(vote_l_data_net != vote_m_data_net))/2

#theorethical max n of edges 
tmax = 19*18/2
```


